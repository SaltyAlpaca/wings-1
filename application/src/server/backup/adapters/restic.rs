use crate::{
    io::{
        compression::{CompressionLevel, writer::CompressionWriter},
        counting_reader::CountingReader,
    },
    models::DirectoryEntry,
    remote::backups::{RawServerBackup, ResticBackupConfiguration},
    response::ApiResponse,
    server::{
        backup::{Backup, BackupCleanExt, BackupCreateExt, BackupExt, BackupFindExt},
        filesystem::{
            archive::StreamableArchiveFormat,
            cap::FileType,
            encode_mode,
            virtualfs::{
                AsyncFileRead, ByteRange, DirectoryListing, DirectoryStreamWalk, DirectoryWalk,
                FileMetadata, FileRead, IsIgnoredFn, VirtualReadableFilesystem,
            },
        },
    },
    utils::PortableModeExt,
};
use axum::http::HeaderMap;
use chrono::{Datelike, Timelike};
use compact_str::ToCompactString;
use human_bytes::human_bytes;
use serde::Deserialize;
use std::{
    collections::HashMap,
    io::{Read, Write},
    path::{Path, PathBuf},
    sync::{
        Arc, LazyLock,
        atomic::{AtomicU64, Ordering},
    },
};
use tokio::{io::AsyncBufReadExt, process::Command, sync::RwLock};

type ResticBackupCache =
    RwLock<HashMap<uuid::Uuid, (ResticSnapshot, Arc<ResticBackupConfiguration>)>>;
static RESTIC_BACKUP_CACHE: LazyLock<ResticBackupCache> =
    LazyLock::new(|| RwLock::new(HashMap::new()));

#[derive(Debug, Deserialize)]
struct ResticSnapshot {
    short_id: String,
    tags: Vec<String>,
    paths: Vec<String>,
}

#[derive(Deserialize)]
#[serde(rename_all = "lowercase")]
enum ResticEntryType {
    File,
    Dir,
    Symlink,
}

#[derive(Deserialize)]
pub struct ResticDirectoryEntry {
    r#type: ResticEntryType,
    path: PathBuf,
    mode: u32,
    size: Option<u64>,
    mtime: chrono::DateTime<chrono::Utc>,
}

pub struct ResticBackup {
    uuid: uuid::Uuid,
    short_id: String,

    config: Arc<crate::config::Config>,
    server_path: PathBuf,
    configuration: Arc<ResticBackupConfiguration>,
}

#[async_trait::async_trait]
impl BackupFindExt for ResticBackup {
    async fn exists(
        config: &Arc<crate::config::Config>,
        uuid: uuid::Uuid,
    ) -> Result<bool, anyhow::Error> {
        if RESTIC_BACKUP_CACHE.read().await.contains_key(&uuid) {
            return Ok(true);
        }

        if tokio::fs::metadata(&config.system.backups.restic.password_file)
            .await
            .is_ok()
        {
            let output = match Command::new("restic")
                .envs(&config.system.backups.restic.environment)
                .arg("--json")
                .arg("--no-lock")
                .arg("--repo")
                .arg(&config.system.backups.restic.repository)
                .arg("--password-file")
                .arg(&config.system.backups.restic.password_file)
                .arg("snapshots")
                .output()
                .await
            {
                Ok(output) => output,
                Err(err) => {
                    return Err(anyhow::anyhow!(
                        "failed to check restic backup existence: {:#?}",
                        err
                    ));
                }
            };

            if output.status.success() {
                let snapshots: Vec<ResticSnapshot> =
                    serde_json::from_slice(&output.stdout).unwrap_or_default();
                let configuration = Arc::new(ResticBackupConfiguration {
                    repository: config.system.backups.restic.repository.clone(),
                    password_file: Some(config.system.backups.restic.password_file.clone()),
                    retry_lock_seconds: config.system.backups.restic.retry_lock_seconds,
                    environment: config.system.backups.restic.environment.clone(),
                });

                let mut found = false;
                let mut cache = RESTIC_BACKUP_CACHE.write().await;
                for snapshot in snapshots {
                    let snapshot_uuid = match snapshot.tags.first() {
                        Some(tag) => match uuid::Uuid::parse_str(tag) {
                            Ok(uuid) => uuid,
                            Err(_) => continue,
                        },
                        _ => continue,
                    };

                    if snapshot_uuid == uuid {
                        found = true;
                    }

                    cache.insert(snapshot_uuid, (snapshot, Arc::clone(&configuration)));
                }
                drop(cache);

                if found {
                    return Ok(true);
                }
            }
        }

        if let Ok(configuration) = config.client.backup_restic_configuration(uuid).await {
            let output = match Command::new("restic")
                .envs(&configuration.environment)
                .arg("--json")
                .arg("--no-lock")
                .arg("--repo")
                .arg(&configuration.repository)
                .arg("snapshots")
                .output()
                .await
            {
                Ok(output) => output,
                Err(err) => {
                    return Err(anyhow::anyhow!(
                        "failed to check restic backup existence: {:#?}",
                        err
                    ));
                }
            };

            if output.status.success() {
                let snapshots: Vec<ResticSnapshot> =
                    serde_json::from_slice(&output.stdout).unwrap_or_default();
                let configuration = Arc::new(configuration.clone());

                let mut found = false;
                let mut cache = RESTIC_BACKUP_CACHE.write().await;
                for snapshot in snapshots {
                    let snapshot_uuid = match snapshot.tags.first() {
                        Some(tag) => match uuid::Uuid::parse_str(tag) {
                            Ok(uuid) => uuid,
                            Err(_) => continue,
                        },
                        _ => continue,
                    };

                    if snapshot_uuid == uuid {
                        found = true;
                    }

                    cache.insert(snapshot_uuid, (snapshot, Arc::clone(&configuration)));
                }
                drop(cache);

                if found {
                    return Ok(true);
                }
            }
        }

        Ok(false)
    }

    async fn find(
        config: &Arc<crate::config::Config>,
        uuid: uuid::Uuid,
    ) -> Result<Option<Backup>, anyhow::Error> {
        if let Some((snapshot, configuration)) = RESTIC_BACKUP_CACHE.read().await.get(&uuid) {
            return Ok(Some(Backup::Restic(ResticBackup {
                uuid,
                short_id: snapshot.short_id.clone(),
                config: Arc::clone(config),
                server_path: match snapshot.paths.first() {
                    Some(path) => PathBuf::from(path),
                    None => {
                        return Err(anyhow::anyhow!(
                            "no paths found in restic snapshot for uuid: {}",
                            uuid
                        ));
                    }
                },
                configuration: Arc::clone(configuration),
            })));
        }

        if tokio::fs::metadata(&config.system.backups.restic.password_file)
            .await
            .is_ok()
        {
            let output = match Command::new("restic")
                .envs(&config.system.backups.restic.environment)
                .arg("--json")
                .arg("--no-lock")
                .arg("--repo")
                .arg(&config.system.backups.restic.repository)
                .arg("--password-file")
                .arg(&config.system.backups.restic.password_file)
                .arg("snapshots")
                .output()
                .await
            {
                Ok(output) => output,
                Err(err) => {
                    return Err(anyhow::anyhow!("failed to find restic backup: {:?}", err));
                }
            };

            if output.status.success() {
                let snapshots: Vec<ResticSnapshot> =
                    serde_json::from_slice(&output.stdout).unwrap_or_default();
                let configuration = Arc::new(ResticBackupConfiguration {
                    repository: config.system.backups.restic.repository.clone(),
                    password_file: Some(config.system.backups.restic.password_file.clone()),
                    retry_lock_seconds: config.system.backups.restic.retry_lock_seconds,
                    environment: config.system.backups.restic.environment.clone(),
                });

                let mut backup = None;
                let mut cache = RESTIC_BACKUP_CACHE.write().await;
                for snapshot in snapshots {
                    let snapshot_uuid = match snapshot.tags.first() {
                        Some(tag) => match uuid::Uuid::parse_str(tag) {
                            Ok(uuid) => uuid,
                            Err(_) => continue,
                        },
                        _ => continue,
                    };

                    if snapshot_uuid == uuid {
                        backup = Some(ResticBackup {
                            uuid,
                            short_id: snapshot.short_id.clone(),
                            config: Arc::clone(config),
                            server_path: match snapshot.paths.first() {
                                Some(path) => PathBuf::from(path),
                                None => {
                                    return Err(anyhow::anyhow!(
                                        "no paths found in restic snapshot for uuid: {}",
                                        uuid
                                    ));
                                }
                            },
                            configuration: Arc::clone(&configuration),
                        });
                    }

                    cache.insert(snapshot_uuid, (snapshot, Arc::clone(&configuration)));
                }
                drop(cache);

                if let Some(backup) = backup {
                    return Ok(Some(Backup::Restic(backup)));
                }
            }
        }

        if let Ok(configuration) = config.client.backup_restic_configuration(uuid).await {
            let output = match Command::new("restic")
                .envs(&configuration.environment)
                .arg("--json")
                .arg("--no-lock")
                .arg("--repo")
                .arg(&configuration.repository)
                .arg("snapshots")
                .output()
                .await
            {
                Ok(output) => output,
                Err(err) => {
                    return Err(anyhow::anyhow!("failed to find restic backup: {:?}", err));
                }
            };

            if output.status.success() {
                let snapshots: Vec<ResticSnapshot> =
                    serde_json::from_slice(&output.stdout).unwrap_or_default();
                let configuration = Arc::new(configuration.clone());

                let mut backup = None;
                let mut cache = RESTIC_BACKUP_CACHE.write().await;
                for snapshot in snapshots {
                    let snapshot_uuid = match snapshot.tags.first() {
                        Some(tag) => match uuid::Uuid::parse_str(tag) {
                            Ok(uuid) => uuid,
                            Err(_) => continue,
                        },
                        _ => continue,
                    };

                    if snapshot_uuid == uuid {
                        backup = Some(ResticBackup {
                            uuid,
                            short_id: snapshot.short_id.clone(),
                            config: Arc::clone(config),
                            server_path: match snapshot.paths.first() {
                                Some(path) => PathBuf::from(path),
                                None => {
                                    return Err(anyhow::anyhow!(
                                        "no paths found in restic snapshot for uuid: {}",
                                        uuid
                                    ));
                                }
                            },
                            configuration: Arc::clone(&configuration),
                        });
                    }

                    cache.insert(snapshot_uuid, (snapshot, Arc::clone(&configuration)));
                }
                drop(cache);

                if let Some(backup) = backup {
                    return Ok(Some(Backup::Restic(backup)));
                }
            }
        }

        Ok(None)
    }
}

#[async_trait::async_trait]
impl BackupCreateExt for ResticBackup {
    async fn create(
        server: &crate::server::Server,
        uuid: uuid::Uuid,
        progress: Arc<AtomicU64>,
        total: Arc<AtomicU64>,
        _ignore: ignore::gitignore::Gitignore,
        ignore_raw: compact_str::CompactString,
    ) -> Result<RawServerBackup, anyhow::Error> {
        let mut excluded_paths = Vec::new();
        for line in ignore_raw.lines() {
            excluded_paths.push("--exclude");
            excluded_paths.push(line);
        }

        let (mut child, configuration) =
            if tokio::fs::metadata(&server.app_state.config.system.backups.restic.password_file)
                .await
                .is_ok()
            {
                (
                    Command::new("restic")
                        .envs(&server.app_state.config.system.backups.restic.environment)
                        .arg("--json")
                        .arg("--repo")
                        .arg(&server.app_state.config.system.backups.restic.repository)
                        .arg("--password-file")
                        .arg(&server.app_state.config.system.backups.restic.password_file)
                        .arg("--retry-lock")
                        .arg(format!(
                            "{}s",
                            server
                                .app_state
                                .config
                                .system
                                .backups
                                .restic
                                .retry_lock_seconds
                        ))
                        .arg("backup")
                        .arg(&server.filesystem.base_path)
                        .args(&excluded_paths)
                        .arg("--tag")
                        .arg(uuid.to_string())
                        .arg("--group-by")
                        .arg("tags")
                        .arg("--limit-download")
                        .arg(
                            (server.app_state.config.system.backups.read_limit.as_kib())
                                .to_compact_string(),
                        )
                        .arg("--limit-upload")
                        .arg(
                            (server.app_state.config.system.backups.write_limit.as_kib())
                                .to_compact_string(),
                        )
                        .stdout(std::process::Stdio::piped())
                        .stderr(std::process::Stdio::piped())
                        .spawn()?,
                    ResticBackupConfiguration {
                        repository: server
                            .app_state
                            .config
                            .system
                            .backups
                            .restic
                            .repository
                            .clone(),
                        password_file: Some(
                            server
                                .app_state
                                .config
                                .system
                                .backups
                                .restic
                                .password_file
                                .clone(),
                        ),
                        retry_lock_seconds: server
                            .app_state
                            .config
                            .system
                            .backups
                            .restic
                            .retry_lock_seconds,
                        environment: server
                            .app_state
                            .config
                            .system
                            .backups
                            .restic
                            .environment
                            .clone(),
                    },
                )
            } else {
                let configuration = server
                    .app_state
                    .config
                    .client
                    .backup_restic_configuration(uuid)
                    .await?;

                (
                    Command::new("restic")
                        .envs(&configuration.environment)
                        .arg("--json")
                        .arg("--repo")
                        .arg(&configuration.repository)
                        .arg("--retry-lock")
                        .arg(format!("{}s", configuration.retry_lock_seconds))
                        .arg("backup")
                        .arg(&server.filesystem.base_path)
                        .args(&excluded_paths)
                        .arg("--tag")
                        .arg(uuid.to_string())
                        .arg("--group-by")
                        .arg("tags")
                        .arg("--limit-download")
                        .arg(
                            (server.app_state.config.system.backups.read_limit.as_kib())
                                .to_compact_string(),
                        )
                        .arg("--limit-upload")
                        .arg(
                            (server.app_state.config.system.backups.write_limit.as_kib())
                                .to_compact_string(),
                        )
                        .stdout(std::process::Stdio::piped())
                        .stderr(std::process::Stdio::piped())
                        .spawn()?,
                    configuration,
                )
            };

        let mut line_reader = tokio::io::BufReader::new(child.stdout.take().unwrap()).lines();

        let mut snapshot_id = None;
        let mut total_bytes_processed = 0;
        let mut total_files_processed = 0;

        while let Ok(Some(line)) = line_reader.next_line().await {
            if let Ok(json) = serde_json::from_str::<serde_json::Value>(&line) {
                if json.get("message_type").and_then(|v| v.as_str()) == Some("status") {
                    let bytes_done = json.get("bytes_done").and_then(|v| v.as_u64()).unwrap_or(0);
                    let total_bytes = json
                        .get("total_bytes")
                        .and_then(|v| v.as_u64())
                        .unwrap_or(0);

                    progress.store(bytes_done, Ordering::SeqCst);
                    total.store(total_bytes, Ordering::SeqCst);
                } else if json.get("message_type").and_then(|v| v.as_str()) == Some("summary") {
                    total_bytes_processed = json
                        .get("total_bytes_processed")
                        .and_then(|v| v.as_u64())
                        .unwrap_or(0);
                    total_files_processed = json
                        .get("total_files_processed")
                        .and_then(|v| v.as_u64())
                        .unwrap_or(0);
                    snapshot_id = json
                        .get("snapshot_id")
                        .and_then(|v| v.as_str())
                        .map(String::from);
                }
            }
        }

        let output = child.wait_with_output().await?;

        if !output.status.success() {
            return Err(anyhow::anyhow!(
                "Failed to create Restic backup for {}: {}",
                server.filesystem.base_path.display(),
                String::from_utf8_lossy(&output.stderr)
            ));
        }

        if let Some(snapshot_id) = &snapshot_id {
            let mut cache = RESTIC_BACKUP_CACHE.write().await;
            cache.insert(
                uuid,
                (
                    ResticSnapshot {
                        short_id: snapshot_id.clone(),
                        tags: vec![uuid.to_string()],
                        paths: vec![server.filesystem.base_path.to_string_lossy().to_string()],
                    },
                    Arc::new(configuration),
                ),
            );
        }

        Ok(RawServerBackup {
            checksum: snapshot_id.unwrap_or_else(|| "unknown".to_string()),
            checksum_type: "restic".into(),
            size: total_bytes_processed,
            files: total_files_processed,
            successful: true,
            browsable: true,
            streaming: true,
            parts: vec![],
        })
    }
}

#[async_trait::async_trait]
impl BackupExt for ResticBackup {
    #[inline]
    fn uuid(&self) -> uuid::Uuid {
        self.uuid
    }

    async fn download(
        &self,
        config: &Arc<crate::config::Config>,
        archive_format: StreamableArchiveFormat,
        _range: Option<ByteRange>,
    ) -> Result<crate::response::ApiResponse, anyhow::Error> {
        let compression_level = config.system.backups.compression_level;
        let (reader, writer) = tokio::io::duplex(crate::BUFFER_SIZE);

        match archive_format {
            StreamableArchiveFormat::Zip => {
                let child = std::process::Command::new("restic")
                    .envs(&self.configuration.environment)
                    .arg("--json")
                    .arg("--no-lock")
                    .arg("--repo")
                    .arg(&self.configuration.repository)
                    .args(self.configuration.password())
                    .arg("dump")
                    .arg(format!("{}:{}", self.short_id, self.server_path.display()))
                    .arg("/")
                    .stdout(std::process::Stdio::piped())
                    .stderr(std::process::Stdio::null())
                    .spawn()?;

                crate::spawn_blocking_handled(move || -> Result<(), anyhow::Error> {
                    let writer = tokio_util::io::SyncIoBridge::new(writer);
                    let mut archive = zip::ZipWriter::new_stream(writer);

                    let mut subtar = tar::Archive::new(child.stdout.unwrap());
                    let mut entries = subtar.entries()?;

                    let mut read_buffer = vec![0; crate::BUFFER_SIZE];
                    while let Some(Ok(mut entry)) = entries.next() {
                        let header = entry.header().clone();
                        let relative = entry.path()?;

                        let mut options: zip::write::FileOptions<'_, ()> =
                            zip::write::FileOptions::default()
                                .compression_level(
                                    Some(compression_level.to_deflate_level() as i64),
                                )
                                .unix_permissions(header.mode()?)
                                .large_file(header.size()? >= u32::MAX as u64);
                        if let Ok(mtime) = header.mtime()
                            && let Some(mtime) = chrono::DateTime::from_timestamp(mtime as i64, 0)
                        {
                            options =
                                options.last_modified_time(zip::DateTime::from_date_and_time(
                                    mtime.year() as u16,
                                    mtime.month() as u8,
                                    mtime.day() as u8,
                                    mtime.hour() as u8,
                                    mtime.minute() as u8,
                                    mtime.second() as u8,
                                )?);
                        }

                        match header.entry_type() {
                            tar::EntryType::Directory => {
                                archive.add_directory(relative.to_string_lossy(), options)?;
                            }
                            tar::EntryType::Regular => {
                                archive.start_file(relative.to_string_lossy(), options)?;
                                crate::io::copy_shared(&mut read_buffer, &mut entry, &mut archive)?;
                            }
                            _ => continue,
                        }
                    }

                    Ok(())
                });
            }
            _ => {
                let child = std::process::Command::new("restic")
                    .envs(&self.configuration.environment)
                    .arg("--json")
                    .arg("--no-lock")
                    .arg("--repo")
                    .arg(&self.configuration.repository)
                    .args(self.configuration.password())
                    .arg("dump")
                    .arg(format!("{}:{}", self.short_id, self.server_path.display()))
                    .arg("/")
                    .stdout(std::process::Stdio::piped())
                    .stderr(std::process::Stdio::null())
                    .spawn()?;

                let file_compression_threads = self.config.api.file_compression_threads;
                crate::spawn_blocking_handled(move || -> Result<(), anyhow::Error> {
                    let mut writer = CompressionWriter::new(
                        tokio_util::io::SyncIoBridge::new(writer),
                        archive_format.compression_format(),
                        compression_level,
                        file_compression_threads,
                    )?;

                    if let Err(err) = crate::io::copy(&mut child.stdout.unwrap(), &mut writer) {
                        tracing::error!(
                            "failed to compress tar archive for restic backup: {}",
                            err
                        );
                    }

                    writer.finish()?;

                    Ok(())
                });
            }
        }

        let mut headers = HeaderMap::with_capacity(2);
        headers.insert(
            "Content-Disposition",
            format!(
                "attachment; filename={}.{}",
                self.uuid,
                archive_format.extension()
            )
            .parse()?,
        );
        headers.insert("Content-Type", archive_format.mime_type().parse()?);

        Ok(ApiResponse::new_stream(reader).with_headers(headers))
    }

    async fn restore(
        &self,
        server: &crate::server::Server,
        progress: Arc<AtomicU64>,
        total: Arc<AtomicU64>,
        _download_url: Option<compact_str::CompactString>,
    ) -> Result<(), anyhow::Error> {
        let child = Command::new("restic")
            .envs(&self.configuration.environment)
            .arg("--json")
            .arg("--no-lock")
            .arg("--repo")
            .arg(&self.configuration.repository)
            .args(self.configuration.password())
            .arg("restore")
            .arg(format!("{}:{}", self.short_id, self.server_path.display()))
            .arg("--target")
            .arg(&server.filesystem.base_path)
            .arg("--limit-download")
            .arg((server.app_state.config.system.backups.read_limit.as_kib()).to_compact_string())
            .stdout(std::process::Stdio::piped())
            .spawn()?;

        let mut line_reader = tokio::io::BufReader::new(child.stdout.unwrap()).lines();

        while let Ok(Some(line)) = line_reader.next_line().await {
            if let Ok(json) = serde_json::from_str::<serde_json::Value>(&line)
                && json.get("message_type").and_then(|v| v.as_str()) == Some("status")
            {
                let total_bytes = json
                    .get("total_bytes")
                    .and_then(|v| v.as_u64())
                    .unwrap_or(0);
                let bytes_restored = json
                    .get("bytes_restored")
                    .and_then(|v| v.as_u64())
                    .unwrap_or(0);
                let percent_done = json
                    .get("percent_done")
                    .and_then(|v| v.as_f64())
                    .unwrap_or(0.0);
                let percent_done = (percent_done * 10000.0).round() / 100.0;

                progress.store(bytes_restored, Ordering::SeqCst);
                total.store(total_bytes, Ordering::SeqCst);

                server.log_daemon(compact_str::format_compact!(
                    "(restoring): {} of {} ({}%)",
                    human_bytes(bytes_restored as f64),
                    human_bytes(total_bytes as f64),
                    percent_done
                ));
            }
        }

        server.filesystem.rerun_disk_checker();

        Ok(())
    }

    async fn delete(&self, _config: &Arc<crate::config::Config>) -> Result<(), anyhow::Error> {
        let output = Command::new("restic")
            .envs(&self.configuration.environment)
            .arg("--repo")
            .arg(&self.configuration.repository)
            .args(self.configuration.password())
            .arg("--retry-lock")
            .arg(format!("{}s", self.configuration.retry_lock_seconds))
            .arg("forget")
            .arg(&self.short_id)
            .arg("--group-by")
            .arg("tags")
            .arg("--prune")
            .output()
            .await?;

        if !output.status.success() {
            return Err(anyhow::anyhow!(
                "failed to delete restic backup: {}",
                String::from_utf8_lossy(&output.stderr)
            ));
        }

        let mut cache = RESTIC_BACKUP_CACHE.write().await;
        cache.remove(&self.uuid);

        Ok(())
    }

    async fn browse(
        &self,
        server: &crate::server::Server,
    ) -> Result<Arc<dyn VirtualReadableFilesystem>, anyhow::Error> {
        let child = Command::new("restic")
            .envs(&self.configuration.environment)
            .arg("--json")
            .arg("--repo")
            .arg(&self.configuration.repository)
            .args(self.configuration.password())
            .arg("--retry-lock")
            .arg(format!("{}s", self.configuration.retry_lock_seconds))
            .arg("ls")
            .arg(format!("{}:{}", self.short_id, self.server_path.display()))
            .arg("/")
            .arg("--recursive")
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::null())
            .spawn()?;

        let mut line_reader = tokio::io::BufReader::new(child.stdout.unwrap()).lines();
        let mut entries = Vec::new();

        while let Ok(Some(line)) = line_reader.next_line().await {
            if line.is_empty() {
                continue;
            }

            if let Ok(mut entry) = serde_json::from_str::<ResticDirectoryEntry>(&line) {
                entry.path = entry
                    .path
                    .strip_prefix(Path::new("/"))
                    .unwrap_or(&entry.path)
                    .to_owned();

                entries.push(entry);
            }
        }

        Ok(Arc::new(VirtualResticBackup {
            server: server.clone(),
            short_id: self.short_id.clone(),
            server_path: self.server_path.clone(),
            configuration: Arc::clone(&self.configuration),
            entries: Arc::new(entries),
        }))
    }
}

#[async_trait::async_trait]
impl BackupCleanExt for ResticBackup {
    async fn clean(
        _server: &crate::server::Server,
        _uuid: uuid::Uuid,
    ) -> Result<(), anyhow::Error> {
        Ok(())
    }
}

pub struct VirtualResticBackup {
    pub server: crate::server::Server,
    pub short_id: String,
    pub server_path: PathBuf,
    pub configuration: Arc<ResticBackupConfiguration>,
    pub entries: Arc<Vec<ResticDirectoryEntry>>,
}

impl VirtualResticBackup {
    fn restic_entry_to_directory_entry(
        &self,
        path: &Path,
        entry: &ResticDirectoryEntry,
        buffer: Option<&[u8]>,
    ) -> DirectoryEntry {
        let size = match entry.r#type {
            ResticEntryType::File => entry.size.unwrap_or(0),
            ResticEntryType::Dir => self
                .entries
                .iter()
                .filter(|e| e.path.starts_with(&entry.path))
                .map(|e| e.size.unwrap_or(0))
                .sum(),
            _ => 0,
        };

        let mime_type = if matches!(entry.r#type, ResticEntryType::Dir) {
            "inode/directory"
        } else if matches!(entry.r#type, ResticEntryType::Symlink) {
            "inode/symlink"
        } else if let Some(buffer) = buffer {
            if let Some(mime) = infer::get(buffer) {
                mime.mime_type()
            } else if let Some(mime) = new_mime_guess::from_path(&entry.path).iter_raw().next() {
                mime
            } else if crate::utils::is_valid_utf8_slice(buffer) || buffer.is_empty() {
                "text/plain"
            } else {
                "application/octet-stream"
            }
        } else {
            new_mime_guess::from_path(&entry.path)
                .first_raw()
                .unwrap_or("application/octet-stream")
        };

        DirectoryEntry {
            name: path
                .file_name()
                .unwrap_or_default()
                .to_string_lossy()
                .into(),
            created: chrono::DateTime::from_timestamp(0, 0).unwrap_or_default(),
            modified: entry.mtime,
            mode: encode_mode(entry.mode),
            mode_bits: compact_str::format_compact!("{:o}", entry.mode & 0o777),
            size,
            directory: matches!(entry.r#type, ResticEntryType::Dir),
            file: matches!(entry.r#type, ResticEntryType::File),
            symlink: matches!(entry.r#type, ResticEntryType::Symlink),
            mime: mime_type,
        }
    }

    fn restic_entry_to_file_type(entry: &ResticDirectoryEntry) -> FileType {
        match entry.r#type {
            ResticEntryType::Dir => FileType::Dir,
            ResticEntryType::File => FileType::File,
            ResticEntryType::Symlink => FileType::Symlink,
        }
    }
}

#[async_trait::async_trait]
impl VirtualReadableFilesystem for VirtualResticBackup {
    fn backing_server(&self) -> &crate::server::Server {
        &self.server
    }

    fn metadata(
        &self,
        path: &(dyn AsRef<Path> + Send + Sync),
    ) -> Result<FileMetadata, anyhow::Error> {
        if path.as_ref() == Path::new("") || path.as_ref() == Path::new("/") {
            return Ok(FileMetadata {
                file_type: FileType::Dir,
                permissions: cap_std::fs::Permissions::from_portable_mode(0o755),
                size: 0,
                modified: None,
                created: None,
            });
        }

        let path = path.as_ref();
        let entry = self
            .entries
            .iter()
            .find(|e| e.path == path)
            .ok_or_else(|| anyhow::anyhow!(std::io::Error::from(rustix::io::Errno::NOENT)))?;

        Ok(FileMetadata {
            file_type: Self::restic_entry_to_file_type(entry),
            permissions: cap_std::fs::Permissions::from_portable_mode(entry.mode & 0o777),
            size: entry.size.unwrap_or(0),
            modified: Some(entry.mtime.into()),
            created: None,
        })
    }
    async fn async_metadata(
        &self,
        path: &(dyn AsRef<Path> + Send + Sync),
    ) -> Result<FileMetadata, anyhow::Error> {
        self.metadata(path)
    }

    fn symlink_metadata(
        &self,
        path: &(dyn AsRef<Path> + Send + Sync),
    ) -> Result<FileMetadata, anyhow::Error> {
        self.metadata(path)
    }
    async fn async_symlink_metadata(
        &self,
        path: &(dyn AsRef<Path> + Send + Sync),
    ) -> Result<FileMetadata, anyhow::Error> {
        self.metadata(path)
    }

    async fn async_directory_entry(
        &self,
        path: &(dyn AsRef<Path> + Send + Sync),
    ) -> Result<DirectoryEntry, anyhow::Error> {
        let path = path.as_ref();
        let entry = self
            .entries
            .iter()
            .find(|e| e.path == path)
            .ok_or_else(|| anyhow::anyhow!(std::io::Error::from(rustix::io::Errno::NOENT)))?;

        Ok(self.restic_entry_to_directory_entry(path, entry, None))
    }

    async fn async_directory_entry_buffer(
        &self,
        path: &(dyn AsRef<Path> + Send + Sync),
        buffer: &[u8],
    ) -> Result<DirectoryEntry, anyhow::Error> {
        let path = path.as_ref();
        let entry = self
            .entries
            .iter()
            .find(|e| e.path == path)
            .ok_or_else(|| anyhow::anyhow!(std::io::Error::from(rustix::io::Errno::NOENT)))?;

        Ok(self.restic_entry_to_directory_entry(path, entry, Some(buffer)))
    }

    async fn async_read_dir(
        &self,
        path: &(dyn AsRef<Path> + Send + Sync),
        per_page: Option<usize>,
        page: usize,
        is_ignored: IsIgnoredFn,
    ) -> Result<DirectoryListing, anyhow::Error> {
        let path = path.as_ref().to_path_buf();
        let mut directory_entries = Vec::new();
        let mut other_entries = Vec::new();

        let path_len = path.components().count();
        for entry in self.entries.iter() {
            let name = &entry.path;

            let name_len = name.components().count();
            if name_len < path_len
                || !name.starts_with(&path)
                || name == &path
                || name_len > path_len + 1
            {
                continue;
            }

            if (is_ignored)(Self::restic_entry_to_file_type(entry), name.clone()).is_none() {
                continue;
            }

            if matches!(entry.r#type, ResticEntryType::Dir) {
                directory_entries.push(entry);
            } else {
                other_entries.push(entry);
            }
        }

        directory_entries.sort_unstable_by(|a, b| a.path.cmp(&b.path));
        other_entries.sort_unstable_by(|a, b| a.path.cmp(&b.path));

        let total_entries = directory_entries.len() + other_entries.len();
        let mut entries = Vec::new();

        if let Some(per_page) = per_page {
            let start = (page - 1) * per_page;

            for entry in directory_entries
                .iter()
                .chain(other_entries.iter())
                .skip(start)
                .take(per_page)
            {
                entries.push(self.restic_entry_to_directory_entry(&entry.path, entry, None));
            }
        } else {
            for entry in directory_entries.iter().chain(other_entries.iter()) {
                entries.push(self.restic_entry_to_directory_entry(&entry.path, entry, None));
            }
        }

        Ok(DirectoryListing {
            total_entries,
            entries,
        })
    }

    async fn async_walk_dir<'a>(
        &'a self,
        path: &(dyn AsRef<Path> + Send + Sync),
        is_ignored: IsIgnoredFn,
    ) -> Result<Box<dyn DirectoryWalk + Send + Sync + 'a>, anyhow::Error> {
        struct ResticWalkDir {
            entries: Arc<Vec<ResticDirectoryEntry>>,
            index: usize,
            path: PathBuf,
            is_ignored: IsIgnoredFn,
        }

        #[async_trait::async_trait]
        impl DirectoryWalk for ResticWalkDir {
            async fn next_entry(&mut self) -> Option<Result<(FileType, PathBuf), anyhow::Error>> {
                while self.index < self.entries.len() {
                    let entry = &self.entries[self.index];
                    self.index += 1;

                    let name = &entry.path;
                    if !name.starts_with(&self.path) || name == &self.path {
                        continue;
                    }

                    let file_type = VirtualResticBackup::restic_entry_to_file_type(entry);
                    if let Some(path) = (self.is_ignored)(file_type, name.clone()) {
                        return Some(Ok((file_type, path)));
                    }
                }
                None
            }
        }

        Ok(Box::new(ResticWalkDir {
            entries: self.entries.clone(),
            index: 0,
            path: path.as_ref().to_path_buf(),
            is_ignored,
        }))
    }

    async fn async_walk_dir_stream<'a>(
        &'a self,
        _path: &(dyn AsRef<Path> + Send + Sync),
        _is_ignored: IsIgnoredFn,
    ) -> Result<Box<dyn DirectoryStreamWalk + Send + Sync + 'a>, anyhow::Error> {
        Err(anyhow::anyhow!(
            "Streamed directory walking is not supported for Restic backups"
        ))
    }

    fn read_file(
        &self,
        path: &(dyn AsRef<Path> + Send + Sync),
        _range: Option<ByteRange>,
    ) -> Result<FileRead, anyhow::Error> {
        let path = path.as_ref();
        let entry = self
            .entries
            .iter()
            .find(|e| e.path == path)
            .ok_or_else(|| anyhow::anyhow!(std::io::Error::from(rustix::io::Errno::NOENT)))?;

        if !matches!(entry.r#type, ResticEntryType::File) {
            return Err(anyhow::anyhow!(std::io::Error::from(
                rustix::io::Errno::NOENT
            )));
        }

        let full_path = PathBuf::from(&self.server_path).join(&entry.path);

        let child = std::process::Command::new("restic")
            .envs(&self.configuration.environment)
            .arg("--json")
            .arg("--no-lock")
            .arg("--repo")
            .arg(&self.configuration.repository)
            .args(self.configuration.password())
            .arg("dump")
            .arg(&self.short_id)
            .arg(full_path)
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::null())
            .spawn()?;

        Ok(FileRead {
            size: entry.size.unwrap_or(0),
            total_size: entry.size.unwrap_or(0),
            reader_range: None,
            reader: Box::new(child.stdout.unwrap()),
        })
    }
    async fn async_read_file(
        &self,
        path: &(dyn AsRef<Path> + Send + Sync),
        _range: Option<ByteRange>,
    ) -> Result<AsyncFileRead, anyhow::Error> {
        let path = path.as_ref();
        let entry = self
            .entries
            .iter()
            .find(|e| e.path == path)
            .ok_or_else(|| anyhow::anyhow!(std::io::Error::from(rustix::io::Errno::NOENT)))?;

        if !matches!(entry.r#type, ResticEntryType::File) {
            return Err(anyhow::anyhow!(std::io::Error::from(
                rustix::io::Errno::NOENT
            )));
        }

        let full_path = PathBuf::from(&self.server_path).join(&entry.path);

        let child = Command::new("restic")
            .envs(&self.configuration.environment)
            .arg("--json")
            .arg("--no-lock")
            .arg("--repo")
            .arg(&self.configuration.repository)
            .args(self.configuration.password())
            .arg("dump")
            .arg(&self.short_id)
            .arg(full_path)
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::null())
            .spawn()?;

        Ok(AsyncFileRead {
            size: entry.size.unwrap_or(0),
            total_size: entry.size.unwrap_or(0),
            reader_range: None,
            reader: Box::new(child.stdout.unwrap()),
        })
    }

    fn read_symlink(
        &self,
        _path: &(dyn AsRef<Path> + Send + Sync),
    ) -> Result<PathBuf, anyhow::Error> {
        Err(anyhow::anyhow!(
            "Symlink reading is not supported for Restic backups"
        ))
    }
    async fn async_read_symlink(
        &self,
        path: &(dyn AsRef<Path> + Send + Sync),
    ) -> Result<PathBuf, anyhow::Error> {
        self.read_symlink(path)
    }

    async fn async_read_dir_archive(
        &self,
        path: &(dyn AsRef<Path> + Send + Sync),
        archive_format: StreamableArchiveFormat,
        compression_level: CompressionLevel,
        bytes_archived: Option<Arc<AtomicU64>>,
        is_ignored: IsIgnoredFn,
    ) -> Result<tokio::io::DuplexStream, anyhow::Error> {
        let path = path.as_ref().to_path_buf();
        let entry = self
            .entries
            .iter()
            .find(|e| e.path == path)
            .ok_or_else(|| anyhow::anyhow!(std::io::Error::from(rustix::io::Errno::NOENT)))?;

        if !matches!(entry.r#type, ResticEntryType::Dir) {
            return Err(anyhow::anyhow!(std::io::Error::from(
                rustix::io::Errno::NOENT
            )));
        }

        let full_path = PathBuf::from(&self.server_path).join(&entry.path);

        let (reader, writer) = tokio::io::duplex(crate::BUFFER_SIZE);

        let configuration = self.configuration.clone();
        let short_id = self.short_id.clone();
        let file_compression_threads = self.server.app_state.config.api.file_compression_threads;

        let spawn_restic = move || {
            std::process::Command::new("restic")
                .envs(&configuration.environment)
                .arg("--json")
                .arg("--no-lock")
                .arg("--repo")
                .arg(&configuration.repository)
                .args(configuration.password())
                .arg("dump")
                .arg(format!("{}:{}", short_id, full_path.display()))
                .arg("/")
                .stdout(std::process::Stdio::piped())
                .stderr(std::process::Stdio::null())
                .spawn()
        };

        match archive_format {
            StreamableArchiveFormat::Zip => {
                crate::spawn_blocking_handled(move || -> Result<(), anyhow::Error> {
                    let mut child = spawn_restic()?;

                    let writer = tokio_util::io::SyncIoBridge::new(writer);
                    let mut archive = zip::ZipWriter::new_stream(writer);

                    let mut subtar = tar::Archive::new(child.stdout.take().unwrap());
                    let mut entries = subtar.entries()?;

                    let mut read_buffer = vec![0; crate::BUFFER_SIZE];
                    while let Some(Ok(mut entry)) = entries.next() {
                        let header = entry.header().clone();
                        let relative = entry.path()?.to_path_buf();

                        let file_type = match header.entry_type() {
                            tar::EntryType::Directory => FileType::Dir,
                            tar::EntryType::Regular => FileType::File,
                            tar::EntryType::Symlink => FileType::Symlink,
                            _ => continue,
                        };

                        let absolute_path = path.join(&relative);
                        if (is_ignored)(file_type, absolute_path).is_none() {
                            continue;
                        }

                        let mut options: zip::write::FileOptions<'_, ()> =
                            zip::write::FileOptions::default()
                                .compression_level(
                                    Some(compression_level.to_deflate_level() as i64),
                                )
                                .unix_permissions(header.mode()?)
                                .large_file(header.size()? >= u32::MAX as u64);

                        if let Ok(mtime) = header.mtime()
                            && let Some(mtime) = chrono::DateTime::from_timestamp(mtime as i64, 0)
                        {
                            options =
                                options.last_modified_time(zip::DateTime::from_date_and_time(
                                    mtime.year() as u16,
                                    mtime.month() as u8,
                                    mtime.day() as u8,
                                    mtime.hour() as u8,
                                    mtime.minute() as u8,
                                    mtime.second() as u8,
                                )?);
                        }

                        match header.entry_type() {
                            tar::EntryType::Directory => {
                                archive.add_directory(relative.to_string_lossy(), options)?;
                            }
                            tar::EntryType::Regular => {
                                archive.start_file(relative.to_string_lossy(), options)?;

                                loop {
                                    let n = entry.read(&mut read_buffer)?;
                                    if n == 0 {
                                        break;
                                    }
                                    archive.write_all(&read_buffer[..n])?;
                                    if let Some(counter) = &bytes_archived {
                                        counter.fetch_add(n as u64, Ordering::SeqCst);
                                    }
                                }
                            }
                            _ => continue,
                        }
                    }

                    let mut inner = archive.finish()?;
                    inner.flush()?;

                    Ok(())
                });
            }
            _ => {
                crate::spawn_blocking_handled(move || -> Result<(), anyhow::Error> {
                    let mut child = spawn_restic()?;

                    let writer = CompressionWriter::new(
                        tokio_util::io::SyncIoBridge::new(writer),
                        archive_format.compression_format(),
                        compression_level,
                        file_compression_threads,
                    )?;

                    let mut subtar = tar::Archive::new(child.stdout.take().unwrap());
                    let mut entries = subtar.entries()?;

                    let mut out_tar = tar::Builder::new(writer);

                    while let Some(Ok(entry)) = entries.next() {
                        let mut header = entry.header().clone();
                        let relative = entry.path()?.to_path_buf();

                        let file_type = match header.entry_type() {
                            tar::EntryType::Directory => FileType::Dir,
                            tar::EntryType::Regular => FileType::File,
                            tar::EntryType::Symlink => FileType::Symlink,
                            _ => continue,
                        };

                        let absolute_path = path.join(&relative);
                        if (is_ignored)(file_type, absolute_path).is_none() {
                            continue;
                        }

                        if file_type.is_file() {
                            if let Some(counter) = &bytes_archived {
                                let counting_reader =
                                    CountingReader::new_with_bytes_read(entry, counter.clone());
                                out_tar.append_data(&mut header, relative, counting_reader)?;
                            } else {
                                out_tar.append_data(&mut header, relative, entry)?;
                            }
                        } else {
                            out_tar.append_data(&mut header, relative, std::io::empty())?;
                        }
                    }

                    out_tar.finish()?;
                    let mut inner = out_tar.into_inner()?.finish()?;
                    inner.flush()?;

                    Ok(())
                });
            }
        }

        Ok(reader)
    }
}
